import math
import json
import base64
import uuid

import PyImGui
import Py4GW

from Py4GWCoreLib.ImGui import ImGui
from Py4GWCoreLib.Agent import Agent
from Py4GWCoreLib.Player import Player
from Py4GWCoreLib.enums_src.GameData_enums import Range
from Py4GWCoreLib.py4gwcorelib_src.Color import Color, ColorPalette
from Py4GWCoreLib.Overlay import Overlay
from Py4GWCoreLib.IniManager import IniManager


INI_PATH = "HeroAI"
FORMATIONS_INI_FILENAME = "FollowModule_Formations.ini"
SETTINGS_INI_FILENAME = "FollowModule_Settings.ini"
FORMATIONS_INI_KEY = ""
SETTINGS_INI_KEY = ""

SEC_EDITOR = "Editor"
SEC_FORMATIONS = "Formations"
SEC_WINDOWS = "Windows"
SEC_PREFIX = "Formation:"
SEC_ID_PREFIX = "FormationId:"

DEFAULT_FORMATION_NAME = "Default"
GRID_STEP_WORLD = Range.Touch.value / 2
SNAP_STEP_WORLD = GRID_STEP_WORLD / 2
MAX_FOLLOW_SLOTS = 11  # followers only (leader is slot 0 / skipped)
MODULE_NAME = "Following Module"
EXPORT_PREFIX = "PY4GWFF1:"
MODULE_ICON = "Textures\\Module_Icons\\FollowModule.png"

class RingConfig:
    def __init__(self, radius: Range | float, color: Color, thickness: int, show=True):
        self.caption = radius.name if isinstance(radius, Range) else f"{radius:.1f}"
        self.show = bool(show)
        self.radius = float(radius.value if isinstance(radius, Range) else radius)
        self.color = color
        self.thickness = int(thickness)


class FollowerPoint:
    def __init__(self, x=0.0, y=0.0, color: Color | None = None):
        self.x = float(x)
        self.y = float(y)
        self.color = (color or ColorPalette.GetColor("white")).copy()

    def copy(self) -> "FollowerPoint":
        return FollowerPoint(self.x, self.y, self.color.copy())


class GeneratorConfig:
    # layout presets
    PRESETS = [
        "Arc",
        "Line",
        "Circle",
        "Wedge",
        "Double Backline",
        "Spread",
    ]
    SYMMETRIES = ["MirroredPairs", "Clockwise", "CounterClockwise"]

    def __init__(self):
        self.preset_index = 0
        self.slot_count = 4
        self.base_radius = float(Range.Touch.value)
        self.radius_step = float(Range.Touch.value / 2)
        self.base_angle_deg = 180.0
        self.angle_step_deg = 25.0
        self.symmetry_index = 0
        self.snap_to_grid = True
        self.rank1_count = 4
        self.rank2_count = 4
        self.rank3_count = 3

    def copy(self) -> "GeneratorConfig":
        g = GeneratorConfig()
        g.preset_index = self.preset_index
        g.slot_count = self.slot_count
        g.base_radius = self.base_radius
        g.radius_step = self.radius_step
        g.base_angle_deg = self.base_angle_deg
        g.angle_step_deg = self.angle_step_deg
        g.symmetry_index = self.symmetry_index
        g.snap_to_grid = self.snap_to_grid
        g.rank1_count = self.rank1_count
        g.rank2_count = self.rank2_count
        g.rank3_count = self.rank3_count
        return g


class Formation:
    MODES = ["freeform", "generated", "generated_with_overrides"]

    def __init__(self, name: str, formation_id: str | None = None):
        self.id = _safe_formation_id(formation_id) if formation_id else _new_formation_id()
        self.name = name
        self.mode_index = 1  # generated by default
        self.points: list[FollowerPoint] = []  # resolved/freeform points
        self.generator = GeneratorConfig()
        self.slot_overrides: dict[int, FollowerPoint] = {}
        self.notes = ""

    @property
    def mode(self) -> str:
        return Formation.MODES[self.mode_index]

    def copy(self, new_name: str) -> "Formation":
        f = Formation(new_name)
        f.mode_index = self.mode_index
        f.points = [p.copy() for p in self.points]
        f.generator = self.generator.copy()
        f.slot_overrides = {k: v.copy() for k, v in self.slot_overrides.items()}
        f.notes = self.notes
        return f


class UIState:
    def __init__(self):
        self.formations: list[Formation] = []
        self.selected_formation_index = 0
        self.formation_name_input = DEFAULT_FORMATION_NAME
        self.selected_slot_index = 0
        self.dragging_slot_index = -1

        self.show_control_window = True
        self.show_editor_window = True
        self.show_canvas_window = True
        self.editor_tab_index = 0

        self.show_canvas = True
        self.canvas_size:tuple = (480, 480)
        self.canvas_scale = 0.45
        self.canvas_click_add = False  # generator-first workflow
        self.canvas_drag_edit = True
        self.canvas_snap_to_grid = True

        self.draw_area_rings = True
        self.draw_3d_area_rings = True
        self.show_party_preview = True

        self.point_default_color = ColorPalette.GetColor("white")
        self.last_status = ""
        self.transfer_buffer = ""

        self.data_loaded = False
        self.formations_dirty = False
        self.shared_mem_dirty = False

        self.area_rings = [
            RingConfig(Range.Touch.value / 2, ColorPalette.GetColor("gw_green"), 2),
            RingConfig(Range.Touch, ColorPalette.GetColor("gw_assassin"), 2, False),
            RingConfig(Range.Adjacent, ColorPalette.GetColor("gw_blue"), 2),
            RingConfig(Range.Nearby, ColorPalette.GetColor("blue"), 2),
            RingConfig(Range.Area, ColorPalette.GetColor("firebrick"), 2),
            RingConfig(Range.Earshot, ColorPalette.GetColor("gw_purple"), 2, False),
            RingConfig(Range.Spellcast, ColorPalette.GetColor("gold"), 2, False),
        ]


ui = UIState()


def _log_action(message: str):
    try:
        Py4GW.Console.Log(MODULE_NAME, message, Py4GW.Console.MessageType.Info)
    except Exception:
        pass


def _ini_reload_now(key: str):
    if not key:
        return
    try:
        IniManager().reload(key)
    except Exception:
        pass


def _ini_write_now(key: str, section: str, name: str, value):
    # Synchronous write for explicit Save actions (avoids deferred flush races).
    im = IniManager()
    node = im._get_node(key)  # project-local API; used to guarantee immediate persistence
    if not node:
        return
    try:
        node.ini_handler.write_key(section, name, value)
        k = (section, name)
        if hasattr(node, "cached_values") and node.cached_values is not None:
            node.cached_values[k] = str(value)
        if hasattr(node, "pending_writes") and node.pending_writes is not None and k in node.pending_writes:
            del node.pending_writes[k]
    except Exception:
        # Fallback to staged write if direct path fails
        im.write_key(key, section, name, value)


def _ini_delete_section_now(key: str, section: str):
    im = IniManager()
    node = im._get_node(key)
    if node:
        try:
            node.ini_handler.delete_section(section)
            if hasattr(node, "cached_values") and node.cached_values is not None:
                for k in [k for k in node.cached_values.keys() if k[0] == section]:
                    del node.cached_values[k]
            if hasattr(node, "pending_writes") and node.pending_writes is not None:
                for k in [k for k in node.pending_writes.keys() if k[0] == section]:
                    del node.pending_writes[k]
            return
        except Exception:
            pass
    im.delete_section(key, section)


def _ensure_global_ini_key_strict(path: str, filename: str) -> str:
    im = IniManager()
    key = im.ensure_global_key(path, filename)
    if not key:
        return ""
    try:
        node = im._get_node(key)
        if node and getattr(node, "is_global", False):
            return key
        # Rebind if a non-global handler was already cached under the same key.
        if hasattr(im, "_handlers") and key in im._handlers:
            del im._handlers[key]
        key = im.ensure_global_key(path, filename)
    except Exception:
        pass
    return key


def _get_ini_filename(key: str) -> str:
    try:
        node = IniManager()._get_node(key)
        if node and getattr(node, "ini_handler", None):
            return str(node.ini_handler.filename)
    except Exception:
        pass
    return ""


def _sec_formation(name: str) -> str:
    safe = "".join(ch for ch in (name or "").strip() if ch not in "[]\r\n\t")
    if not safe:
        safe = DEFAULT_FORMATION_NAME
    return f"{SEC_PREFIX}{safe}"


def _safe_name(name: str) -> str:
    return _sec_formation(name)[len(SEC_PREFIX):]


def _safe_formation_id(value: str | None) -> str:
    s = "".join(ch for ch in str(value or "").strip().lower() if ch.isalnum() or ch in ("_", "-"))
    return s[:64] if s else _new_formation_id()


def _new_formation_id() -> str:
    return uuid.uuid4().hex


def _sec_formation_id(formation_id: str) -> str:
    return f"{SEC_ID_PREFIX}{_safe_formation_id(formation_id)}"


def _color_to_str(c: Color) -> str:
    r, g, b, a = c.to_tuple()
    return f"{r},{g},{b},{a}"


def _color_from_str(value: str, fallback: Color | None = None) -> Color:
    fb = (fallback or ColorPalette.GetColor("white")).copy()
    try:
        parts = [int(p.strip()) for p in str(value).split(",")]
        if len(parts) != 4:
            return fb
        return Color(parts[0], parts[1], parts[2], parts[3])
    except Exception:
        return fb


def _mark_formations_dirty(shared_dirty=True):
    ui.formations_dirty = True
    if shared_dirty:
        ui.shared_mem_dirty = True


def _current_formation() -> Formation:
    if not ui.formations:
        ui.formations.append(Formation(DEFAULT_FORMATION_NAME))
    ui.selected_formation_index = max(0, min(ui.selected_formation_index, len(ui.formations) - 1))
    return ui.formations[ui.selected_formation_index]


def _set_selected_formation(index: int):
    if not ui.formations:
        return
    ui.selected_formation_index = max(0, min(index, len(ui.formations) - 1))
    ui.formation_name_input = _current_formation().name
    ui.selected_slot_index = max(0, min(ui.selected_slot_index, len(_resolved_points()) - 1 if _resolved_points() else 0))


def _next_unique_name(base: str) -> str:
    base = _safe_name(base)
    existing = {f.name for f in ui.formations}
    if base not in existing:
        return base
    i = 2
    while f"{base} {i}" in existing:
        i += 1
    return f"{base} {i}"


def _snap(v: float) -> float:
    if not ui.canvas_snap_to_grid:
        return float(v)
    return round(v / SNAP_STEP_WORLD) * SNAP_STEP_WORLD


def _slot_color(slot_index: int) -> Color:
    palette = [
        "gw_white", "gw_blue", "gw_green", "gold", "gw_purple", "firebrick",
        "gw_assassin", "aqua", "orange", "pink", "light_green"
    ]
    return ColorPalette.GetColor(palette[slot_index % len(palette)]).copy()


def _point_to_canvas(center_x: float, center_y: float, pt: FollowerPoint) -> tuple[float, float]:
    # Preserve original canvas mapping:
    # local +X draws left, local +Y draws down
    return (
        center_x + (-pt.x * ui.canvas_scale),
        center_y + (pt.y * ui.canvas_scale),
    )


def _canvas_to_world(center_x: float, center_y: float, mouse_x: float, mouse_y: float) -> tuple[float, float]:
    # Inverse of _point_to_canvas (original draft math)
    wx = -(mouse_x - center_x) / max(ui.canvas_scale, 0.01)
    wy = (mouse_y - center_y) / max(ui.canvas_scale, 0.01)
    return (_snap(wx), _snap(wy))


def _polar_to_local(angle_deg: float, radius: float) -> tuple[float, float]:
    """
    Convert generator angle/radius into the same local point space used by the original module.
    Angle convention:
    - 0 deg = forward (up on canvas)
    - +90 deg = right of leader
    This preserves compatibility with the original canvas/world transforms.
    """
    rad = math.radians(angle_deg)
    x = -math.sin(rad) * radius
    y = -math.cos(rad) * radius
    return x, y


def _find_canvas_slot(center_x: float, center_y: float, mouse_x: float, mouse_y: float) -> int:
    pts = _resolved_points()
    if not pts:
        return -1
    pick_r = max(12.0, (Range.Touch.value / 2) * ui.canvas_scale)
    best = -1
    best_d2 = pick_r * pick_r
    for i, pt in enumerate(pts):
        px, py = _point_to_canvas(center_x, center_y, pt)
        dx = mouse_x - px
        dy = mouse_y - py
        d2 = (dx * dx) + (dy * dy)
        if d2 <= best_d2:
            best = i
            best_d2 = d2
    return best


def _ranked_count_list(g: GeneratorConfig) -> list[int]:
    counts = [max(0, g.rank1_count), max(0, g.rank2_count), max(0, g.rank3_count)]
    counts = [c for c in counts if c > 0]
    if not counts:
        counts = [max(1, g.slot_count)]
    return counts


def _generate_points(g: GeneratorConfig) -> list[FollowerPoint]:
    count = max(0, min(MAX_FOLLOW_SLOTS, int(g.slot_count)))
    if count <= 0:
        return []

    preset = GeneratorConfig.PRESETS[g.preset_index]
    pts: list[FollowerPoint] = []

    def add_xy(x: float, y: float, idx: int):
        if g.snap_to_grid:
            x = round(x / GRID_STEP_WORLD) * GRID_STEP_WORLD
            y = round(y / GRID_STEP_WORLD) * GRID_STEP_WORLD
        pts.append(FollowerPoint(x, y, _slot_color(idx)))

    if preset == "Line":
        for i in range(count):
            angle_deg = g.base_angle_deg + (i * g.angle_step_deg)
            r = g.base_radius
            x, y = _polar_to_local(angle_deg, r)
            add_xy(x, y, i)

    elif preset == "Circle":
        step = 360.0 / max(1, count)
        for i in range(count):
            x, y = _polar_to_local(g.base_angle_deg + (i * step), g.base_radius)
            add_xy(x, y, i)

    elif preset == "Wedge":
        mid = (count - 1) / 2.0
        for i in range(count):
            rel = i - mid
            angle_deg = g.base_angle_deg + (rel * g.angle_step_deg)
            r = g.base_radius + (abs(rel) * g.radius_step * 0.35)
            x, y = _polar_to_local(angle_deg, r)
            add_xy(x, y, i)

    elif preset == "Double Backline":
        # front and back rank split
        front = min(count, max(1, (count + 1) // 2))
        back = count - front
        idx = 0
        for rank_i, rank_count in enumerate([front, back]):
            if rank_count <= 0:
                continue
            radius = g.base_radius + (rank_i * max(1.0, g.radius_step))
            mid = (rank_count - 1) / 2.0
            for j in range(rank_count):
                angle_deg = g.base_angle_deg + ((j - mid) * g.angle_step_deg)
                x, y = _polar_to_local(angle_deg, radius)
                add_xy(x, y, idx)
                idx += 1

    elif preset == "Spread":
        counts = _ranked_count_list(g)
        idx = 0
        for rank_i, rank_count in enumerate(counts):
            if idx >= count:
                break
            radius = g.base_radius + (rank_i * max(1.0, g.radius_step))
            local_count = min(rank_count, count - idx)
            mid = (local_count - 1) / 2.0
            for j in range(local_count):
                angle_deg = g.base_angle_deg + ((j - mid) * (g.angle_step_deg * (1 + rank_i * 0.25)))
                x, y = _polar_to_local(angle_deg, radius)
                add_xy(x, y, idx)
                idx += 1

    else:  # Arc (default)
        if g.symmetry_index == 0:  # mirrored pairs
            for i in range(count):
                if i == 0:
                    angle_deg = g.base_angle_deg
                else:
                    side = -1 if i % 2 else 1
                    k = (i + 1) // 2
                    angle_deg = g.base_angle_deg + (side * k * g.angle_step_deg)
                x, y = _polar_to_local(angle_deg, g.base_radius)
                add_xy(x, y, i)
        else:
            sign = 1 if g.symmetry_index == 1 else -1
            for i in range(count):
                angle_deg = g.base_angle_deg + (sign * i * g.angle_step_deg)
                x, y = _polar_to_local(angle_deg, g.base_radius)
                add_xy(x, y, i)

    return pts[:count]


def _resolved_points() -> list[FollowerPoint]:
    f = _current_formation()
    if f.mode == "freeform":
        return f.points

    base = _generate_points(f.generator)
    if f.mode == "generated_with_overrides":
        for slot, pt in f.slot_overrides.items():
            if 0 <= slot < len(base):
                base[slot] = pt.copy()
    f.points = [p.copy() for p in base]
    return f.points


def _ensure_slot_count(slot_count: int):
    f = _current_formation()
    slot_count = max(0, min(MAX_FOLLOW_SLOTS, slot_count))
    if f.mode == "freeform":
        while len(f.points) < slot_count:
            f.points.append(FollowerPoint(0.0, 0.0, _slot_color(len(f.points))))
        if len(f.points) > slot_count:
            f.points = f.points[:slot_count]
    else:
        f.generator.slot_count = slot_count
        # prune overrides out of range
        f.slot_overrides = {k: v for k, v in f.slot_overrides.items() if k < slot_count}
        _resolved_points()
    ui.selected_slot_index = max(0, min(ui.selected_slot_index, max(0, slot_count - 1)))


def _set_slot_point(slot_index: int, x: float, y: float, color: Color | None = None):
    f = _current_formation()
    pts = _resolved_points()
    if slot_index < 0 or slot_index >= len(pts):
        return

    x = float(_snap(x))
    y = float(_snap(y))
    current_pt = pts[slot_index]
    current_color = current_pt.color if color is None else color
    if (
        abs(current_pt.x - x) <= 1e-6 and
        abs(current_pt.y - y) <= 1e-6 and
        _color_to_str(current_pt.color) == _color_to_str(current_color)
    ):
        return

    if f.mode == "freeform":
        f.points[slot_index].x = x
        f.points[slot_index].y = y
        if color is not None:
            f.points[slot_index].color = color.copy()
    else:
        if f.mode == "generated":
            f.mode_index = 2  # generated_with_overrides
        override = f.slot_overrides.get(slot_index, pts[slot_index].copy())
        override.x = x
        override.y = y
        if color is not None:
            override.color = color.copy()
        f.slot_overrides[slot_index] = override
        _resolved_points()
    _mark_formations_dirty(shared_dirty=True)


def _clear_slot_override(slot_index: int):
    f = _current_formation()
    if f.mode != "generated_with_overrides":
        return
    if slot_index in f.slot_overrides:
        del f.slot_overrides[slot_index]
        _resolved_points()
        _mark_formations_dirty(shared_dirty=True)


def _bake_to_freeform():
    f = _current_formation()
    f.points = [p.copy() for p in _resolved_points()]
    f.slot_overrides.clear()
    f.mode_index = 0
    _mark_formations_dirty(shared_dirty=True)
    ui.last_status = f"Baked '{f.name}' to freeform."


def _regenerate_points():
    f = _current_formation()
    if f.mode == "freeform":
        f.mode_index = 1
    _resolved_points()
    _mark_formations_dirty(shared_dirty=True)
    ui.last_status = f"Regenerated '{f.name}'."


def _reset_generator_defaults():
    f = _current_formation()
    slot_count = max(1, f.generator.slot_count)
    f.generator = GeneratorConfig()
    f.generator.slot_count = slot_count
    if f.mode != "freeform":
        _regenerate_points()


def _load_from_ini():
    im = IniManager()
    _ini_reload_now(FORMATIONS_INI_KEY)
    _ini_reload_now(SETTINGS_INI_KEY)
    entries: list[tuple[str, str]] = []  # (id, name)
    count = max(0, im.read_int(FORMATIONS_INI_KEY, SEC_FORMATIONS, "count", 0))
    for i in range(count):
        fid = _safe_formation_id(im.read_key(FORMATIONS_INI_KEY, SEC_FORMATIONS, f"id_{i}", ""))
        n = _safe_name(im.read_key(FORMATIONS_INI_KEY, SEC_FORMATIONS, f"name_{i}", ""))
        if not n:
            continue
        if any(existing_id == fid for existing_id, _ in entries):
            continue
        entries.append((fid, n))

    ui.formations.clear()
    for fid, listed_name in entries:
        sec = _sec_formation_id(fid)
        legacy_sec = _sec_formation(listed_name)
        has_id_section = bool(im.read_key(FORMATIONS_INI_KEY, sec, "name", ""))
        src_sec = sec if has_id_section else legacy_sec

        stored_name = _safe_name(im.read_key(FORMATIONS_INI_KEY, src_sec, "name", listed_name))
        stored_id = _safe_formation_id(im.read_key(FORMATIONS_INI_KEY, src_sec, "id", fid))
        f = Formation(stored_name, stored_id)
        f.mode_index = max(0, min(2, im.read_int(FORMATIONS_INI_KEY, src_sec, "mode_index", f.mode_index)))
        f.notes = im.read_key(FORMATIONS_INI_KEY, src_sec, "notes", "")

        g = f.generator
        g.preset_index = max(0, min(len(GeneratorConfig.PRESETS) - 1, im.read_int(FORMATIONS_INI_KEY, src_sec, "g_preset_index", g.preset_index)))
        g.slot_count = max(0, min(MAX_FOLLOW_SLOTS, im.read_int(FORMATIONS_INI_KEY, src_sec, "g_slot_count", g.slot_count)))
        g.base_radius = im.read_float(FORMATIONS_INI_KEY, src_sec, "g_base_radius", g.base_radius)
        g.radius_step = im.read_float(FORMATIONS_INI_KEY, src_sec, "g_radius_step", g.radius_step)
        g.base_angle_deg = im.read_float(FORMATIONS_INI_KEY, src_sec, "g_base_angle_deg", g.base_angle_deg)
        g.angle_step_deg = im.read_float(FORMATIONS_INI_KEY, src_sec, "g_angle_step_deg", g.angle_step_deg)
        g.symmetry_index = max(0, min(len(GeneratorConfig.SYMMETRIES) - 1, im.read_int(FORMATIONS_INI_KEY, src_sec, "g_symmetry_index", g.symmetry_index)))
        g.snap_to_grid = im.read_bool(FORMATIONS_INI_KEY, src_sec, "g_snap_to_grid", g.snap_to_grid)
        g.rank1_count = im.read_int(FORMATIONS_INI_KEY, src_sec, "g_rank1_count", g.rank1_count)
        g.rank2_count = im.read_int(FORMATIONS_INI_KEY, src_sec, "g_rank2_count", g.rank2_count)
        g.rank3_count = im.read_int(FORMATIONS_INI_KEY, src_sec, "g_rank3_count", g.rank3_count)

        point_count = max(0, min(MAX_FOLLOW_SLOTS, im.read_int(FORMATIONS_INI_KEY, src_sec, "point_count", 0)))
        for j in range(point_count):
            x = im.read_float(FORMATIONS_INI_KEY, src_sec, f"p{j}_x", 0.0)
            y = im.read_float(FORMATIONS_INI_KEY, src_sec, f"p{j}_y", 0.0)
            c = _color_from_str(im.read_key(FORMATIONS_INI_KEY, src_sec, f"p{j}_c", ""), _slot_color(j))
            f.points.append(FollowerPoint(x, y, c))

        override_count = max(0, min(MAX_FOLLOW_SLOTS, im.read_int(FORMATIONS_INI_KEY, src_sec, "override_count", 0)))
        for j in range(override_count):
            slot = im.read_int(FORMATIONS_INI_KEY, src_sec, f"o{j}_slot", -1)
            if slot < 0 or slot >= MAX_FOLLOW_SLOTS:
                continue
            x = im.read_float(FORMATIONS_INI_KEY, src_sec, f"o{j}_x", 0.0)
            y = im.read_float(FORMATIONS_INI_KEY, src_sec, f"o{j}_y", 0.0)
            c = _color_from_str(im.read_key(FORMATIONS_INI_KEY, src_sec, f"o{j}_c", ""), _slot_color(slot))
            f.slot_overrides[slot] = FollowerPoint(x, y, c)

        ui.formations.append(f)

    if not ui.formations:
        f = Formation(DEFAULT_FORMATION_NAME)
        f.generator.slot_count = 4
        f.points = _generate_points(f.generator)
        ui.formations = [f]

    selected_id = _safe_formation_id(im.read_key(SETTINGS_INI_KEY, SEC_FORMATIONS, "selected_id", ""))
    selected_name = _safe_name(im.read_key(SETTINGS_INI_KEY, SEC_FORMATIONS, "selected", ui.formations[0].name))
    found = next((i for i, f in enumerate(ui.formations) if f.id == selected_id), -1)
    if found < 0:
        found = 0
        for i, f in enumerate(ui.formations):
            if f.name == selected_name:
                found = i
                break
    _set_selected_formation(found)

    ui.show_control_window = im.read_bool(SETTINGS_INI_KEY, SEC_WINDOWS, "show_control_window", ui.show_control_window)
    ui.show_editor_window = im.read_bool(SETTINGS_INI_KEY, SEC_WINDOWS, "show_editor_window", ui.show_editor_window)
    ui.show_canvas_window = im.read_bool(SETTINGS_INI_KEY, SEC_WINDOWS, "show_canvas_window", ui.show_canvas_window)
    ui.show_canvas = im.read_bool(SETTINGS_INI_KEY, SEC_EDITOR, "show_canvas", ui.show_canvas)
    ui.canvas_scale = im.read_float(SETTINGS_INI_KEY, SEC_EDITOR, "canvas_scale", ui.canvas_scale)
    ui.canvas_size = (
        max(200, im.read_int(SETTINGS_INI_KEY, SEC_EDITOR, "canvas_w", ui.canvas_size[0])),
        max(200, im.read_int(SETTINGS_INI_KEY, SEC_EDITOR, "canvas_h", ui.canvas_size[1])),
    )
    ui.canvas_drag_edit = im.read_bool(SETTINGS_INI_KEY, SEC_EDITOR, "canvas_drag_edit", ui.canvas_drag_edit)
    ui.canvas_snap_to_grid = im.read_bool(SETTINGS_INI_KEY, SEC_EDITOR, "canvas_snap_to_grid", ui.canvas_snap_to_grid)
    ui.draw_area_rings = im.read_bool(SETTINGS_INI_KEY, SEC_EDITOR, "draw_area_rings", ui.draw_area_rings)
    ui.draw_3d_area_rings = im.read_bool(SETTINGS_INI_KEY, SEC_EDITOR, "draw_3d_area_rings", ui.draw_3d_area_rings)
    ui.show_party_preview = im.read_bool(SETTINGS_INI_KEY, SEC_EDITOR, "show_party_preview", ui.show_party_preview)

    ui.formations_dirty = False
    ui.shared_mem_dirty = True
    ui.data_loaded = True


def _save_to_ini():
    im = IniManager()
    _ini_reload_now(FORMATIONS_INI_KEY)
    _ini_reload_now(SETTINGS_INI_KEY)
    prev_count = max(0, im.read_int(FORMATIONS_INI_KEY, SEC_FORMATIONS, "count", 0))
    prev_ids: list[str] = []
    for i in range(prev_count):
        old_id = _safe_formation_id(im.read_key(FORMATIONS_INI_KEY, SEC_FORMATIONS, f"id_{i}", ""))
        if old_id:
            prev_ids.append(old_id)

    _ini_write_now(FORMATIONS_INI_KEY, SEC_FORMATIONS, "count", len(ui.formations))
    for i, f in enumerate(ui.formations):
        _ini_write_now(FORMATIONS_INI_KEY, SEC_FORMATIONS, f"id_{i}", f.id)
        _ini_write_now(FORMATIONS_INI_KEY, SEC_FORMATIONS, f"name_{i}", f.name)

    _ini_write_now(SETTINGS_INI_KEY, SEC_FORMATIONS, "selected_id", _current_formation().id)
    _ini_write_now(SETTINGS_INI_KEY, SEC_FORMATIONS, "selected", _current_formation().name)

    current_ids = {f.id for f in ui.formations}
    for old_id in prev_ids:
        if old_id not in current_ids:
            _ini_delete_section_now(FORMATIONS_INI_KEY, _sec_formation_id(old_id))

    for f in ui.formations:
        sec = _sec_formation_id(f.id)
        _ini_delete_section_now(FORMATIONS_INI_KEY, sec)
        _ini_write_now(FORMATIONS_INI_KEY, sec, "id", f.id)
        _ini_write_now(FORMATIONS_INI_KEY, sec, "name", f.name)
        _ini_write_now(FORMATIONS_INI_KEY, sec, "mode_index", f.mode_index)
        _ini_write_now(FORMATIONS_INI_KEY, sec, "notes", f.notes)

        g = f.generator
        _ini_write_now(FORMATIONS_INI_KEY, sec, "g_preset_index", g.preset_index)
        _ini_write_now(FORMATIONS_INI_KEY, sec, "g_slot_count", g.slot_count)
        _ini_write_now(FORMATIONS_INI_KEY, sec, "g_base_radius", g.base_radius)
        _ini_write_now(FORMATIONS_INI_KEY, sec, "g_radius_step", g.radius_step)
        _ini_write_now(FORMATIONS_INI_KEY, sec, "g_base_angle_deg", g.base_angle_deg)
        _ini_write_now(FORMATIONS_INI_KEY, sec, "g_angle_step_deg", g.angle_step_deg)
        _ini_write_now(FORMATIONS_INI_KEY, sec, "g_symmetry_index", g.symmetry_index)
        _ini_write_now(FORMATIONS_INI_KEY, sec, "g_snap_to_grid", int(g.snap_to_grid))
        _ini_write_now(FORMATIONS_INI_KEY, sec, "g_rank1_count", g.rank1_count)
        _ini_write_now(FORMATIONS_INI_KEY, sec, "g_rank2_count", g.rank2_count)
        _ini_write_now(FORMATIONS_INI_KEY, sec, "g_rank3_count", g.rank3_count)

        pts = _resolved_points() if f is _current_formation() else (f.points if f.mode == "freeform" else _generate_points(f.generator))
        if f.mode == "generated_with_overrides":
            pts = _generate_points(f.generator)
            for k, p in f.slot_overrides.items():
                if 0 <= k < len(pts):
                    pts[k] = p.copy()
        _ini_write_now(FORMATIONS_INI_KEY, sec, "point_count", len(pts))
        for i, p in enumerate(pts):
            _ini_write_now(FORMATIONS_INI_KEY, sec, f"p{i}_x", p.x)
            _ini_write_now(FORMATIONS_INI_KEY, sec, f"p{i}_y", p.y)
            _ini_write_now(FORMATIONS_INI_KEY, sec, f"p{i}_c", _color_to_str(p.color))

        overrides = sorted(f.slot_overrides.items())
        _ini_write_now(FORMATIONS_INI_KEY, sec, "override_count", len(overrides))
        for i, (slot, p) in enumerate(overrides):
            _ini_write_now(FORMATIONS_INI_KEY, sec, f"o{i}_slot", slot)
            _ini_write_now(FORMATIONS_INI_KEY, sec, f"o{i}_x", p.x)
            _ini_write_now(FORMATIONS_INI_KEY, sec, f"o{i}_y", p.y)
            _ini_write_now(FORMATIONS_INI_KEY, sec, f"o{i}_c", _color_to_str(p.color))

    ui.formations_dirty = False


def _save_ui_state_only():
    im = IniManager()
    im.write_key(SETTINGS_INI_KEY, SEC_FORMATIONS, "selected_id", _current_formation().id)
    im.write_key(SETTINGS_INI_KEY, SEC_FORMATIONS, "selected", _current_formation().name)
    im.write_key(SETTINGS_INI_KEY, SEC_WINDOWS, "show_control_window", int(ui.show_control_window))
    im.write_key(SETTINGS_INI_KEY, SEC_WINDOWS, "show_editor_window", int(ui.show_editor_window))
    im.write_key(SETTINGS_INI_KEY, SEC_WINDOWS, "show_canvas_window", int(ui.show_canvas_window))
    im.write_key(SETTINGS_INI_KEY, SEC_EDITOR, "show_canvas", int(ui.show_canvas))
    im.write_key(SETTINGS_INI_KEY, SEC_EDITOR, "canvas_scale", float(ui.canvas_scale))
    im.write_key(SETTINGS_INI_KEY, SEC_EDITOR, "canvas_w", int(ui.canvas_size[0]))
    im.write_key(SETTINGS_INI_KEY, SEC_EDITOR, "canvas_h", int(ui.canvas_size[1]))
    im.write_key(SETTINGS_INI_KEY, SEC_EDITOR, "canvas_drag_edit", int(ui.canvas_drag_edit))
    im.write_key(SETTINGS_INI_KEY, SEC_EDITOR, "canvas_snap_to_grid", int(ui.canvas_snap_to_grid))
    im.write_key(SETTINGS_INI_KEY, SEC_EDITOR, "draw_area_rings", int(ui.draw_area_rings))
    im.write_key(SETTINGS_INI_KEY, SEC_EDITOR, "draw_3d_area_rings", int(ui.draw_3d_area_rings))
    im.write_key(SETTINGS_INI_KEY, SEC_EDITOR, "show_party_preview", int(ui.show_party_preview))


def _formation_to_export_dict(f: Formation) -> dict:
    pts = [p.copy() for p in _resolved_points()] if f is _current_formation() else [p.copy() for p in f.points]
    if f.mode != "freeform":
        pts = _generate_points(f.generator)
        if f.mode == "generated_with_overrides":
            for k, p in f.slot_overrides.items():
                if 0 <= k < len(pts):
                    pts[k] = p.copy()

    return {
        "schema": "py4gw_follow_formation_v1",
        "name": f.name,
        "mode_index": int(f.mode_index),
        "notes": f.notes,
        "generator": {
            "preset_index": int(f.generator.preset_index),
            "slot_count": int(f.generator.slot_count),
            "base_radius": float(f.generator.base_radius),
            "radius_step": float(f.generator.radius_step),
            "base_angle_deg": float(f.generator.base_angle_deg),
            "angle_step_deg": float(f.generator.angle_step_deg),
            "symmetry_index": int(f.generator.symmetry_index),
            "snap_to_grid": bool(f.generator.snap_to_grid),
            "rank1_count": int(f.generator.rank1_count),
            "rank2_count": int(f.generator.rank2_count),
            "rank3_count": int(f.generator.rank3_count),
        },
        "points": [
            {"x": float(p.x), "y": float(p.y), "c": _color_to_str(p.color)}
            for p in pts
        ],
        "overrides": [
            {"slot": int(slot), "x": float(p.x), "y": float(p.y), "c": _color_to_str(p.color)}
            for slot, p in sorted(f.slot_overrides.items())
        ],
    }


def _export_current_formation_to_string() -> str:
    # ASCII-safe transfer format for clipboard/import fields:
    # PREFIX + base64url(json_utf8)
    raw_json = json.dumps(
        _formation_to_export_dict(_current_formation()),
        separators=(",", ":"),
        ensure_ascii=True,
    )
    encoded = base64.urlsafe_b64encode(raw_json.encode("utf-8")).decode("ascii")
    return f"{EXPORT_PREFIX}{encoded}"


def _import_formation_from_string(payload: str) -> bool:
    payload = (payload or "").strip()
    if not payload:
        ui.last_status = "Import failed: empty payload."
        return False

    try:
        if payload.startswith(EXPORT_PREFIX):
            encoded = payload[len(EXPORT_PREFIX):].strip()
            # tolerate missing '=' padding
            if encoded:
                encoded += "=" * ((4 - (len(encoded) % 4)) % 4)
            raw_json = base64.urlsafe_b64decode(encoded.encode("ascii")).decode("utf-8")
            data = json.loads(raw_json)
        else:
            # Backward compatibility with older raw JSON payloads
            data = json.loads(payload)
    except Exception as e:
        ui.last_status = f"Import parse error: {e}"
        return False

    if not isinstance(data, dict) or data.get("schema") != "py4gw_follow_formation_v1":
        ui.last_status = "Import failed: unsupported formation payload."
        return False

    name = _next_unique_name(_safe_name(str(data.get("name", "Imported Formation"))))
    f = Formation(name)
    f.mode_index = max(0, min(2, int(data.get("mode_index", 1))))
    f.notes = str(data.get("notes", ""))[:512]

    g_data = data.get("generator", {}) if isinstance(data.get("generator", {}), dict) else {}
    g = f.generator
    g.preset_index = max(0, min(len(GeneratorConfig.PRESETS) - 1, int(g_data.get("preset_index", g.preset_index))))
    g.slot_count = max(0, min(MAX_FOLLOW_SLOTS, int(g_data.get("slot_count", g.slot_count))))
    g.base_radius = float(g_data.get("base_radius", g.base_radius))
    g.radius_step = float(g_data.get("radius_step", g.radius_step))
    g.base_angle_deg = float(g_data.get("base_angle_deg", g.base_angle_deg))
    g.angle_step_deg = float(g_data.get("angle_step_deg", g.angle_step_deg))
    g.symmetry_index = max(0, min(len(GeneratorConfig.SYMMETRIES) - 1, int(g_data.get("symmetry_index", g.symmetry_index))))
    g.snap_to_grid = bool(g_data.get("snap_to_grid", g.snap_to_grid))
    g.rank1_count = int(g_data.get("rank1_count", g.rank1_count))
    g.rank2_count = int(g_data.get("rank2_count", g.rank2_count))
    g.rank3_count = int(g_data.get("rank3_count", g.rank3_count))

    points_data = data.get("points", [])
    if isinstance(points_data, list):
        for i, item in enumerate(points_data[:MAX_FOLLOW_SLOTS]):
            if not isinstance(item, dict):
                continue
            f.points.append(FollowerPoint(
                float(item.get("x", 0.0)),
                float(item.get("y", 0.0)),
                _color_from_str(str(item.get("c", "")), _slot_color(i))
            ))

    overrides_data = data.get("overrides", [])
    if isinstance(overrides_data, list):
        for item in overrides_data[:MAX_FOLLOW_SLOTS]:
            if not isinstance(item, dict):
                continue
            slot = int(item.get("slot", -1))
            if 0 <= slot < MAX_FOLLOW_SLOTS:
                f.slot_overrides[slot] = FollowerPoint(
                    float(item.get("x", 0.0)),
                    float(item.get("y", 0.0)),
                    _color_from_str(str(item.get("c", "")), _slot_color(slot))
                )

    if f.mode == "freeform":
        _ensure_import_count = min(MAX_FOLLOW_SLOTS, len(f.points))
        f.points = f.points[:_ensure_import_count]
    else:
        if g.slot_count <= 0:
            g.slot_count = min(MAX_FOLLOW_SLOTS, max(1, len(f.points)))

    ui.formations.append(f)
    _set_selected_formation(len(ui.formations) - 1)
    _mark_formations_dirty(shared_dirty=True)
    ui.last_status = f"Imported formation '{f.name}'."
    return True


def _draw_canvas_content():
    if not ui.show_canvas:
        PyImGui.text("Canvas hidden (toggle in Visual window).")
        return
    child_flags = PyImGui.WindowFlags.NoTitleBar | PyImGui.WindowFlags.NoResize | PyImGui.WindowFlags.NoMove
    if not PyImGui.begin_child("FormationCanvasChild", ui.canvas_size, True, child_flags):
        return

    canvas_pos = PyImGui.get_cursor_screen_pos()
    center_x = canvas_pos[0] + ui.canvas_size[0] / 2
    center_y = canvas_pos[1] + ui.canvas_size[1] / 2
    left = canvas_pos[0]
    top = canvas_pos[1]
    right = left + ui.canvas_size[0]
    bottom = top + ui.canvas_size[1]

    # grid
    grid_color = ColorPalette.GetColor("gray").copy()
    grid_color.set_a(80)
    grid_step = GRID_STEP_WORLD * ui.canvas_scale
    x = center_x
    while x <= right:
        PyImGui.draw_list_add_line(x, top, x, bottom, grid_color.to_color(), 1)
        x += grid_step
    x = center_x - grid_step
    while x >= left:
        PyImGui.draw_list_add_line(x, top, x, bottom, grid_color.to_color(), 1)
        x -= grid_step
    y = center_y
    while y <= bottom:
        PyImGui.draw_list_add_line(left, y, right, y, grid_color.to_color(), 1)
        y += grid_step
    y = center_y - grid_step
    while y >= top:
        PyImGui.draw_list_add_line(left, y, right, y, grid_color.to_color(), 1)
        y -= grid_step

    # center touch disk + rings
    touch_color = ColorPalette.GetColor("gw_green").copy()
    touch_color.set_a(70)
    touch_r = (Range.Touch.value / 2) * ui.canvas_scale
    PyImGui.draw_list_add_circle_filled(center_x, center_y, touch_r, touch_color.to_color(), 48)
    if ui.draw_area_rings:
        for ring in ui.area_rings:
            if ring.show:
                PyImGui.draw_list_add_circle(center_x, center_y, ring.radius * ui.canvas_scale, ring.color.to_color(), 32, ring.thickness)

    pts = _resolved_points()
    point_r = (Range.Touch.value / 2) * ui.canvas_scale
    for i, pt in enumerate(pts):
        px, py = _point_to_canvas(center_x, center_y, pt)
        fill = pt.color.copy()
        fill.set_a(120)
        if i == ui.selected_slot_index:
            fill = fill.shift(ColorPalette.GetColor("gold"), 0.35)
        PyImGui.draw_list_add_circle_filled(px, py, point_r, fill.to_color(), 32)
        PyImGui.draw_list_add_circle(px, py, point_r, pt.color.to_color(), 32, 3 if i == ui.selected_slot_index else 2)
        PyImGui.draw_list_add_text(px - 4, py - 6, ColorPalette.GetColor("white").to_color(), str(i + 1))

    # mouse edit
    io = PyImGui.get_io()
    mx = io.mouse_pos_x
    my = io.mouse_pos_y
    inside = (left <= mx <= right and top <= my <= bottom and PyImGui.is_window_hovered())
    if not inside and PyImGui.is_mouse_released(0):
        ui.dragging_slot_index = -1

    if inside:
        if ui.dragging_slot_index != -1:
            if PyImGui.is_mouse_down(0):
                wx, wy = _canvas_to_world(center_x, center_y, mx, my)
                _set_slot_point(ui.dragging_slot_index, wx, wy)
            elif PyImGui.is_mouse_released(0):
                ui.dragging_slot_index = -1
        elif PyImGui.is_mouse_clicked(0):
            hit = _find_canvas_slot(center_x, center_y, mx, my)
            if hit != -1:
                ui.selected_slot_index = hit
                if ui.canvas_drag_edit:
                    ui.dragging_slot_index = hit
            elif ui.canvas_click_add:
                f = _current_formation()
                if f.mode == "freeform" and len(f.points) < MAX_FOLLOW_SLOTS:
                    wx, wy = _canvas_to_world(center_x, center_y, mx, my)
                    f.points.append(FollowerPoint(wx, wy, _slot_color(len(f.points))))
                    ui.selected_slot_index = len(f.points) - 1
                    _mark_formations_dirty(shared_dirty=True)
                    _log_action(f"Added freeform point #{len(f.points)} in canvas for '{f.name}'.")
        elif PyImGui.is_mouse_clicked(1):
            hit = _find_canvas_slot(center_x, center_y, mx, my)
            if hit != -1:
                f = _current_formation()
                if f.mode == "freeform":
                    if 0 <= hit < len(f.points):
                        f.points.pop(hit)
                        ui.selected_slot_index = max(0, min(ui.selected_slot_index, max(0, len(f.points) - 1)))
                        _mark_formations_dirty(shared_dirty=True)
                        _log_action(f"Removed freeform point #{hit + 1} in canvas for '{f.name}'.")
                else:
                    _clear_slot_override(hit)

    PyImGui.end_child()


def _draw_generator_tab():
    f = _current_formation()
    g = f.generator

    old_mode = f.mode_index
    f.mode_index = PyImGui.combo("Mode", f.mode_index, Formation.MODES)
    if f.mode_index != old_mode:
        if f.mode == "freeform" and not f.points:
            f.points = [p.copy() for p in _generate_points(g)]
        _mark_formations_dirty(shared_dirty=True)

    old_preset = g.preset_index
    g.preset_index = PyImGui.combo("Preset", g.preset_index, GeneratorConfig.PRESETS)
    g.symmetry_index = PyImGui.combo("Symmetry", g.symmetry_index, GeneratorConfig.SYMMETRIES)
    g.slot_count = PyImGui.slider_int("Slot Count", int(g.slot_count), 0, MAX_FOLLOW_SLOTS)
    g.base_radius = max(0.0, PyImGui.input_float("Base Radius", float(g.base_radius)))
    g.radius_step = max(0.0, PyImGui.input_float("Radius Step", float(g.radius_step)))
    g.base_angle_deg = PyImGui.input_float("Base Angle Deg", float(g.base_angle_deg))
    g.angle_step_deg = PyImGui.input_float("Angle Step Deg", float(g.angle_step_deg))
    g.snap_to_grid = PyImGui.checkbox("Generator Snap To Grid", g.snap_to_grid)

    if GeneratorConfig.PRESETS[g.preset_index] in ("Spread", "Double Backline"):
        g.rank1_count = max(0, PyImGui.input_int("Rank 1 Count", g.rank1_count))
        g.rank2_count = max(0, PyImGui.input_int("Rank 2 Count", g.rank2_count))
        g.rank3_count = max(0, PyImGui.input_int("Rank 3 Count", g.rank3_count))

    PyImGui.separator()
    if PyImGui.button("Generate / Regenerate"):
        _ensure_slot_count(g.slot_count)
        _regenerate_points()
        _log_action(f"Regenerated formation '{f.name}' using preset '{GeneratorConfig.PRESETS[g.preset_index]}'.")
    PyImGui.same_line(0, 6)
    if PyImGui.button("Bake To Freeform"):
        _bake_to_freeform()
        _log_action(f"Baked formation '{f.name}' to freeform.")
    PyImGui.same_line(0, 6)
    if PyImGui.button("Reset Generator Defaults"):
        _reset_generator_defaults()
        _log_action(f"Reset generator defaults for '{f.name}'.")

    if g.preset_index != old_preset:
        _mark_formations_dirty(shared_dirty=False)

    PyImGui.text_wrapped("Manual moves in generated mode create per-slot overrides automatically.")


def _draw_slots_tab():
    f = _current_formation()
    pts = _resolved_points()

    ui.canvas_snap_to_grid = PyImGui.checkbox("Snap To Half-Grid", ui.canvas_snap_to_grid)

    desired = len(pts) if f.mode != "freeform" else len(f.points)
    desired = PyImGui.slider_int("Active Slots", int(desired), 0, MAX_FOLLOW_SLOTS)
    _ensure_slot_count(desired)
    pts = _resolved_points()

    if PyImGui.button("Add Slot") and desired < MAX_FOLLOW_SLOTS:
        _ensure_slot_count(desired + 1)
        _mark_formations_dirty(shared_dirty=True)
        _log_action(f"Added slot to '{f.name}' (count={desired + 1}).")
        pts = _resolved_points()
    PyImGui.same_line(0, 6)
    if PyImGui.button("Remove Last") and desired > 0:
        _ensure_slot_count(desired - 1)
        _mark_formations_dirty(shared_dirty=True)
        _log_action(f"Removed last slot from '{f.name}' (count={desired - 1}).")
        pts = _resolved_points()
    PyImGui.same_line(0, 6)
    if PyImGui.button("Remove Selected") and desired > 0:
        remove_idx = max(0, min(ui.selected_slot_index, desired - 1))
        if f.mode == "freeform":
            if 0 <= remove_idx < len(f.points):
                f.points.pop(remove_idx)
                ui.selected_slot_index = max(0, min(remove_idx, len(f.points) - 1 if f.points else 0))
                _mark_formations_dirty(shared_dirty=True)
                _log_action(f"Removed selected freeform slot #{remove_idx + 1} from '{f.name}'.")
        else:
            new_count = max(0, desired - 1)
            # Shift overrides above removed slot down by one to preserve slot ordering.
            new_overrides: dict[int, FollowerPoint] = {}
            for k, p in f.slot_overrides.items():
                if k == remove_idx:
                    continue
                nk = k - 1 if k > remove_idx else k
                if nk < new_count:
                    new_overrides[nk] = p.copy()
            f.slot_overrides = new_overrides
            _ensure_slot_count(new_count)
            ui.selected_slot_index = max(0, min(remove_idx, max(0, new_count - 1)))
            _mark_formations_dirty(shared_dirty=True)
            _log_action(f"Removed generated slot #{remove_idx + 1} from '{f.name}' (count={new_count}).")
        pts = _resolved_points()

    if not pts:
        PyImGui.text("No points. Increase slot count or generate a formation.")
        return

    ui.selected_slot_index = max(0, min(ui.selected_slot_index, len(pts) - 1))
    ui.selected_slot_index = PyImGui.slider_int("Selected Slot", ui.selected_slot_index, 0, len(pts) - 1)
    slot = ui.selected_slot_index
    pt = pts[slot]

    new_x_edit = PyImGui.slider_float("X", -pt.x, -Range.Earshot.value / 2, Range.Earshot.value / 2)
    new_y = PyImGui.slider_float("Y", pt.y, -Range.Earshot.value / 2, Range.Earshot.value / 2)
    if new_x_edit != -pt.x or new_y != pt.y:
        _set_slot_point(slot, -new_x_edit, new_y)
        pt = _resolved_points()[slot]

    old_color = pt.color.to_tuple_normalized()
    new_color = PyImGui.color_edit4("Slot Color", old_color)
    if new_color != old_color:
        _set_slot_point(slot, pt.x, pt.y, Color.from_tuple_normalized(new_color))

    if f.mode == "generated_with_overrides":
        if slot in f.slot_overrides and PyImGui.button("Clear Slot Override"):
            _clear_slot_override(slot)
            _log_action(f"Cleared slot override #{slot + 1} in '{f.name}'.")

    PyImGui.separator()
    if PyImGui.begin_table("SlotsTable", 6, PyImGui.TableFlags.Borders | PyImGui.TableFlags.RowBg):
        PyImGui.table_setup_column("#", PyImGui.TableColumnFlags.WidthFixed, 30)
        PyImGui.table_setup_column("X", PyImGui.TableColumnFlags.WidthFixed, 70)
        PyImGui.table_setup_column("Y", PyImGui.TableColumnFlags.WidthFixed, 70)
        PyImGui.table_setup_column("Mode", PyImGui.TableColumnFlags.WidthFixed, 70)
        PyImGui.table_setup_column("Color", PyImGui.TableColumnFlags.WidthFixed, 70)
        PyImGui.table_setup_column("Select", PyImGui.TableColumnFlags.WidthFixed, 55)
        PyImGui.table_headers_row()
        for i, p in enumerate(_resolved_points()):
            PyImGui.table_next_row()
            PyImGui.table_next_column(); PyImGui.text(str(i + 1))
            PyImGui.table_next_column(); PyImGui.text(f"{p.x:.1f}")
            PyImGui.table_next_column(); PyImGui.text(f"{p.y:.1f}")
            PyImGui.table_next_column()
            mode_label = "base"
            if f.mode == "freeform":
                mode_label = "free"
            elif i in f.slot_overrides:
                mode_label = "ovr"
            PyImGui.text(mode_label)
            PyImGui.table_next_column()
            dummy = p.color.to_tuple_normalized()
            PyImGui.color_edit4(f"##slot_c_{i}", dummy)  # display only; no edit callback in table
            PyImGui.table_next_column()
            if PyImGui.small_button(f"S##{i}"):
                ui.selected_slot_index = i
        PyImGui.end_table()


def _draw_preview_tab():
    pts = _resolved_points()
    PyImGui.text(f"Resolved slots: {len(pts)}")
    ui.show_party_preview = PyImGui.checkbox("Show Slot Preview Table", ui.show_party_preview)
    if not ui.show_party_preview:
        return
    if PyImGui.begin_table("FormationPreviewTable", 4, PyImGui.TableFlags.Borders | PyImGui.TableFlags.RowBg):
        PyImGui.table_setup_column("Slot", PyImGui.TableColumnFlags.WidthFixed, 45)
        PyImGui.table_setup_column("Point", PyImGui.TableColumnFlags.WidthFixed, 120)
        PyImGui.table_setup_column("Mode", PyImGui.TableColumnFlags.WidthFixed, 70)
        PyImGui.table_setup_column("Color", PyImGui.TableColumnFlags.WidthFixed, 70)
        PyImGui.table_headers_row()
        f = _current_formation()
        for idx, p in enumerate(pts):
            PyImGui.table_next_row()
            PyImGui.table_next_column(); PyImGui.text(str(idx + 1))
            PyImGui.table_next_column(); PyImGui.text(f"({p.x:.1f}, {p.y:.1f})")
            PyImGui.table_next_column()
            mode_label = "base"
            if f.mode == "freeform":
                mode_label = "free"
            elif idx in f.slot_overrides:
                mode_label = "ovr"
            PyImGui.text(mode_label)
            PyImGui.table_next_column()
            dummy = p.color.to_tuple_normalized()
            PyImGui.color_edit4(f"##pv_col_{idx}", dummy)
        PyImGui.end_table()


def _draw_canvas_tab():
    f = _current_formation()
    PyImGui.text(f"Mode: {f.mode}")
    PyImGui.text_wrapped("Left-click point to select/drag. Right-click point removes freeform point or clears generated override.")
    _draw_canvas_content()


def _draw_visual_tab():
    ui.show_canvas = PyImGui.checkbox("Show Canvas", ui.show_canvas)
    ui.canvas_drag_edit = PyImGui.checkbox("Canvas Drag Edit", ui.canvas_drag_edit)
    ui.canvas_snap_to_grid = PyImGui.checkbox("Canvas Snap To Grid", ui.canvas_snap_to_grid)
    ui.canvas_click_add = PyImGui.checkbox("Canvas Click Add (Freeform)", ui.canvas_click_add)
    ui.draw_area_rings = PyImGui.checkbox("Draw Area Rings", ui.draw_area_rings)
    ui.draw_3d_area_rings = PyImGui.checkbox("Draw 3D Rings", ui.draw_3d_area_rings)
    ui.canvas_scale = PyImGui.slider_float("Canvas Scale", ui.canvas_scale, 0.1, 1.5)
    cw = PyImGui.input_int("Canvas Width", ui.canvas_size[0])
    ch = PyImGui.input_int("Canvas Height", ui.canvas_size[1])
    ui.canvas_size = (max(240, cw), max(240, ch))

    if PyImGui.collapsing_header("Area Rings", PyImGui.TreeNodeFlags.DefaultOpen):
        if PyImGui.begin_table("VisualRings", 4, PyImGui.TableFlags.Borders | PyImGui.TableFlags.RowBg):
            PyImGui.table_setup_column("Show", PyImGui.TableColumnFlags.WidthFixed, 45)
            PyImGui.table_setup_column("Name", PyImGui.TableColumnFlags.WidthFixed, 100)
            PyImGui.table_setup_column("Radius", PyImGui.TableColumnFlags.WidthFixed, 75)
            PyImGui.table_setup_column("Color", PyImGui.TableColumnFlags.WidthFixed, 90)
            PyImGui.table_headers_row()
            for i, ring in enumerate(ui.area_rings):
                PyImGui.table_next_row()
                PyImGui.table_next_column()
                ring.show = PyImGui.checkbox(f"##vr_show_{i}", ring.show)
                PyImGui.table_next_column()
                PyImGui.text(ring.caption)
                PyImGui.table_next_column()
                ring.radius = max(1.0, PyImGui.input_float(f"##vr_rad_{i}", ring.radius))
                PyImGui.table_next_column()
                oldc = ring.color.to_tuple_normalized()
                newc = PyImGui.color_edit4(f"##vr_col_{i}", oldc)
                if newc != oldc:
                    ring.color = Color.from_tuple_normalized(newc)
            PyImGui.end_table()


def _draw_control_window():
    if not ui.show_control_window:
        return
    PyImGui.set_next_window_size((390, 0), PyImGui.ImGuiCond.Once)
    if ImGui.Begin(SETTINGS_INI_KEY, "Formation Control", flags=PyImGui.WindowFlags.AlwaysAutoResize):
        names = [f.name for f in ui.formations] or [DEFAULT_FORMATION_NAME]
        old_sel = ui.selected_formation_index
        ui.selected_formation_index = PyImGui.combo("Formation", ui.selected_formation_index, names)
        if ui.selected_formation_index != old_sel:
            _set_selected_formation(ui.selected_formation_index)
            ui.shared_mem_dirty = True

        ui.formation_name_input = _safe_name(PyImGui.input_text("Name", ui.formation_name_input))

        if PyImGui.button("Rename + Save"):
            f = _current_formation()
            new_name = _safe_name(ui.formation_name_input)
            if new_name != f.name and any(x.name == new_name for x in ui.formations):
                ui.last_status = f"Name '{new_name}' already exists."
            else:
                f.name = new_name
                ui.formation_name_input = new_name
                _mark_formations_dirty(shared_dirty=False)
                _save_to_ini()
                ui.last_status = f"Saved '{new_name}'."
                _log_action(f"Renamed and saved formation '{new_name}'.")
        PyImGui.same_line(0, 6)
        if PyImGui.button("Save All"):
            _save_to_ini()
            ui.last_status = f"Saved all formations to: {_get_ini_filename(FORMATIONS_INI_KEY)}"
            _log_action("Saved all formations.")
        if ui.formations_dirty:
            PyImGui.same_line(0, 8)
            PyImGui.text_colored("Unsaved changes", (1.0, 0.8, 0.2, 1.0))
        PyImGui.same_line(0, 6)
        if PyImGui.button("Export"):
            try:
                ui.transfer_buffer = _export_current_formation_to_string()
                PyImGui.set_clipboard_text(ui.transfer_buffer)
                ui.last_status = "Exported current formation to clipboard."
                _log_action(f"Exported formation '{_current_formation().name}' to clipboard.")
            except Exception as e:
                ui.last_status = f"Export failed: {e}"
                _log_action(f"Export failed for '{_current_formation().name}': {e}")
        if PyImGui.is_item_hovered():
            PyImGui.set_tooltip("Exported formation data is copied to clipboard in a compact format. It can be imported back or shared with others.")
        PyImGui.same_line(0, 6)
        if PyImGui.button("Import"):
            try:
                ui.transfer_buffer = PyImGui.get_clipboard_text() or ""
            except Exception as e:
                ui.last_status = f"Import failed: clipboard error: {e}"
                _log_action(f"Import failed: clipboard read error: {e}")
                ui.transfer_buffer = ""
            if ui.transfer_buffer:
                if _import_formation_from_string(ui.transfer_buffer):
                    _save_to_ini()
                    ui.last_status = "Imported formation from clipboard and saved."
                    _log_action("Imported formation payload from clipboard and saved formations.")
                else:
                    _log_action("Import payload from clipboard failed.")
            elif not ui.last_status.startswith("Import failed: clipboard error:"):
                ui.last_status = "Import failed: clipboard is empty."
                _log_action("Import failed: clipboard was empty.")
        if PyImGui.is_item_hovered():
            PyImGui.set_tooltip("Import formation data from clipboard. Accepts both the compact exported format and older raw JSON format. Current clipboard content will be used if the field is empty.")

        if PyImGui.button("New"):
            new_name = _next_unique_name(ui.formation_name_input or "Formation")
            ui.formations.append(_current_formation().copy(new_name))
            _set_selected_formation(len(ui.formations) - 1)
            _mark_formations_dirty(shared_dirty=True)
            _save_to_ini()
            ui.last_status = f"Created and saved '{new_name}'."
            _log_action(f"Created duplicated formation '{new_name}' and saved formations.")
        PyImGui.same_line(0, 6)
        if PyImGui.button("New Empty"):
            new_name = _next_unique_name("Formation")
            f = Formation(new_name)
            f.mode_index = 0
            f.points = []
            ui.formations.append(f)
            _set_selected_formation(len(ui.formations) - 1)
            _mark_formations_dirty(shared_dirty=True)
            _save_to_ini()
            ui.last_status = f"Created empty and saved '{new_name}'."
            _log_action(f"Created empty formation '{new_name}' and saved formations.")
        PyImGui.same_line(0, 6)
        if PyImGui.button("Delete") and len(ui.formations) > 1:
            deleted_name = _current_formation().name
            ui.formations.pop(ui.selected_formation_index)
            _set_selected_formation(min(ui.selected_formation_index, len(ui.formations) - 1))
            _mark_formations_dirty(shared_dirty=True)
            _save_to_ini()
            ui.last_status = f"Deleted and saved '{deleted_name}'."
            _log_action(f"Deleted formation '{deleted_name}' and saved formations.")

        PyImGui.separator()
        ui.show_canvas_window = PyImGui.checkbox("Show Canvas Window", ui.show_canvas_window)
        ui.show_editor_window = PyImGui.checkbox("Show Editor Window", ui.show_editor_window)

        if ui.last_status:
            PyImGui.separator()
            PyImGui.text_wrapped(ui.last_status)

    ImGui.End(SETTINGS_INI_KEY)


def _draw_editor_window():
    if not ui.show_editor_window:
        return
    target_w = 560
    target_h = 620
    PyImGui.set_next_window_size((target_w, target_h), PyImGui.ImGuiCond.Once)
    if ImGui.Begin(SETTINGS_INI_KEY, "Formation Editor", flags=PyImGui.WindowFlags.NoFlag):
        if PyImGui.begin_tab_bar("FormationEditorTabs"):
            if PyImGui.begin_tab_item("Generator"):
                _draw_generator_tab()
                PyImGui.end_tab_item()
            if PyImGui.begin_tab_item("Slots"):
                _draw_slots_tab()
                PyImGui.end_tab_item()
            if PyImGui.begin_tab_item("Preview"):
                _draw_preview_tab()
                PyImGui.end_tab_item()
            if PyImGui.begin_tab_item("Visuals"):
                _draw_visual_tab()
                PyImGui.end_tab_item()
            PyImGui.end_tab_bar()
    ImGui.End(SETTINGS_INI_KEY)


def _draw_canvas_window():
    if not ui.show_canvas_window:
        return
    target_w = ui.canvas_size[0] + 32
    target_h = ui.canvas_size[1] + 72
    PyImGui.set_next_window_size((target_w, target_h), PyImGui.ImGuiCond.Once)
    if ImGui.Begin(SETTINGS_INI_KEY, "Formation Canvas", flags=PyImGui.WindowFlags.NoFlag):
        _draw_canvas_tab()
    ImGui.End(SETTINGS_INI_KEY)


def _draw_3d_overlay():
    pts = _resolved_points()
    Overlay().BeginDraw()
    try:
        player_id = Player.GetAgentID()
        player_x, player_y, player_z = Agent.GetXYZ(player_id)

        if ui.draw_3d_area_rings:
            grid_color = ColorPalette.GetColor("gray").copy()
            grid_color.set_a(120)
            grid_extent = Range.Spellcast.value
            step = GRID_STEP_WORLD
            origin_x = round(player_x / step) * step
            origin_y = round(player_y / step) * step
            y = origin_y - grid_extent
            while y <= origin_y + grid_extent:
                Overlay().DrawLine3D(origin_x - grid_extent, y, player_z, origin_x + grid_extent, y, player_z, grid_color.to_color(), 1)
                y += step
            x = origin_x - grid_extent
            while x <= origin_x + grid_extent:
                Overlay().DrawLine3D(x, origin_y - grid_extent, player_z, x, origin_y + grid_extent, player_z, grid_color.to_color(), 1)
                x += step

            for ring in ui.area_rings:
                if ring.show:
                    Overlay().DrawPoly3D(player_x, player_y, player_z, ring.radius, ring.color.to_color(), 64, ring.thickness * 2)

        angle = Agent.GetRotationAngle(player_id) - math.pi / 2
        c = -math.cos(angle)
        s = -math.sin(angle)
        radius = Range.Touch.value / 2
        for pt in pts:
            rx = (pt.x * c) - (pt.y * s)
            ry = (pt.x * s) + (pt.y * c)
            Overlay().DrawPoly3D(player_x + rx, player_y + ry, player_z, radius, pt.color.to_color(), 32, 2)
    except Exception:
        pass
    Overlay().EndDraw()


def _init_once():
    global FORMATIONS_INI_KEY, SETTINGS_INI_KEY
    if FORMATIONS_INI_KEY and SETTINGS_INI_KEY:
        return True
    if not FORMATIONS_INI_KEY:
        FORMATIONS_INI_KEY = _ensure_global_ini_key_strict(INI_PATH, FORMATIONS_INI_FILENAME)
    if not SETTINGS_INI_KEY:
        SETTINGS_INI_KEY = _ensure_global_ini_key_strict(INI_PATH, SETTINGS_INI_FILENAME)
    if not FORMATIONS_INI_KEY or not SETTINGS_INI_KEY:
        return False
    _log_action(f"Formations INI: {_get_ini_filename(FORMATIONS_INI_KEY)}")
    _log_action(f"Settings INI: {_get_ini_filename(SETTINGS_INI_KEY)}")
    return True


def main():
    if not _init_once():
        return
    if not ui.data_loaded:
        _load_from_ini()

    _draw_control_window()
    _draw_canvas_window()
    _draw_editor_window()
    _draw_3d_overlay()

    # Persist only lightweight UI state every frame; full formation save is explicit via UI buttons.
    _save_ui_state_only()


if __name__ == "__main__":
    main()
